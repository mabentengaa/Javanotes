ASCII表：0-9对应48-57  
	 a-z对应97-122
	 A-Z对应65-90

char取值范围0-65535

short取值范围-32768 - 32767

数组排序：一般都是升序
选择排序：（每一个都比较）

	足球比赛


冒泡排序：（相邻的比较）



代码格式化：ctrl+shift+f

多行注释  ：Ctrl+shift+/

取消注释  ：Ctrl+shift+\

导包      ：ctrl+shift+o

移动行代码：alt+箭头

复制代码并移动：ctrl+Alt+上下箭头

删除当前行：ctrl+d

意见提示功能：ctrl+1；



arraylist:

add(int 索引，存储的元素)
set（int 索引，修改的元素）
remove（int 索引）：删除
clear（）：清空所有元素


成员变量与局部变量的区别：

1.定义位置不同

2.作用域不同

3.默认值不同（局部变量没有赋值就不能使用）

4.内存位置不同：
	成员变量：跟随对象进入堆内存中
	局部变量：跟谁方法进入栈内存中

5.生命周期不同
	成员变量：跟随对象在堆中存储，内存等待JVM清理，生命周期长
	局部变量：跟随方法，方法出栈，变量死亡，生命周期短


		
	
public static void main(String[] args) {

		int a= 1;
		add(a);
		System.out.println(a);
	}

public static void add(int a) {
		
		a+=5;
	}

//输出结果为1
//进栈后运行add方法，a=6，接着add方法出栈，然而add方法并没有将6赋值给main方法中的a，所以输出结果依然为1；

public class note {
		
	
public static void main(String[] args) {

		person p = new person();
		p.name ="张三";
		add(p); 
		System.out.println(p.name);
		
	}

public static void add(person p) {
		p.name = "李四";
		
	}

}


class person {
	String name ;
}

//输出结果为李四，因为p.name是person的固有属性，跟随person进入堆内，先定义为了张三，后来又定义为了李四，然而方法运行后并没有退出堆，所以修改结果保留了下来。





this：那个对象调用的，this就表示那个对象



如果子类继承了抽象类，但是重写了一部分抽像方法，这个子类还是抽象类，虽然不报错，但是无法new出。




abstract（抽象） 不能和那些关键字共存：

1.private（私有的）

2.final（常量）

3.static（静态）


构造方法在new的时候运行，每new一次执行一次，一个new只运行一次构造方法

1.构造方法可以重载的，并不止一个
2、构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。

this（），将空参中的参数传入匹配的有参的构造方法中,如this("张三",20)，就是将张三和20传给定义了姓名和年龄的构造方法中



调用本类中的构造方法
	this(实参列表);
调用父类中的空参数构造方法
	super();
调用父类中的有参数构造方法
	super(实参列表);

子类构造方法中的第一行，有一个隐式的代码即：super（）；（调用父类的空参构造方法）
不管子类中的构造方法重载多少次，每一个的第一行都是super（）

this()和super()都要在第一行，不能同时存在，任选其一，保证子类每一个构造方法都能访问到父类的构造方法即可

如：

public Student(){

	//调用了自己的构造方法
	//间接的调用了父类的构造方法

	this("sss");
}

public Student(String s){

	//不仅自己调用了，
	//上面的无参也用了

	super(2);

}
无论如何子类的构造方法就直接也可间接也行都要调用父类的构造方法  day12_17 2.3
aaaa
